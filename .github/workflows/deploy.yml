name: CI/CD for Minikube

on:
  push:
    branches: [ main ]


jobs:
  build-and-deploy:
    runs-on: self-hosted
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup .NET with proper permissions
        run: |
          echo "Setting up .NET for self-hosted runner..."
          
          # Check if .NET is already installed
          if command -v dotnet &> /dev/null; then
            echo ".NET is already installed:"
            dotnet --version
            dotnet --list-sdks
          else
            echo "Installing .NET manually..."
            
            # Create local dotnet directory
            mkdir -p $HOME/.dotnet
            export DOTNET_ROOT=$HOME/.dotnet
            export PATH=$DOTNET_ROOT:$PATH
            
            # Download and install .NET
            curl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --channel 9.0 --install-dir $HOME/.dotnet
            
            # Add to PATH for subsequent steps
            echo "DOTNET_ROOT=$HOME/.dotnet" >> $GITHUB_ENV
            echo "$HOME/.dotnet" >> $GITHUB_PATH
            
            echo "Verifying installation:"
            $HOME/.dotnet/dotnet --version
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          driver-opts: |
            network=host

      - name: Build Core API Docker image with retry
        run: |
          echo "Building Core API Docker image with retry logic..."
          
          for attempt in 1 2 3; do
            echo "Attempt $attempt/3 for Core API build..."
            
            if docker buildx build \
              --file Ecom.Core/src/Ecom.Core.API/Dockerfile \
              --tag moclaw/ecom-core-api:latest \
              --load \
              --progress=plain \
              --no-cache-filter=build \
              .; then
              echo "Core API build successful on attempt $attempt"
              break
            else
              echo "Core API build failed on attempt $attempt"
              if [ $attempt -eq 3 ]; then
                echo "All attempts failed for Core API build"
                exit 1
              fi
              echo "Waiting 30 seconds before retry..."
              sleep 30
              
              # Clean up any partial builds
              docker buildx prune -f || true
            fi
          done
          
          echo "Verifying Core API image..."
          docker images | grep moclaw/ecom-core-api

      - name: Build Users API Docker image with retry
        run: |
          echo "Building Users API Docker image with retry logic..."
          
          for attempt in 1 2 3; do
            echo "Attempt $attempt/3 for Users API build..."
            
            if docker buildx build \
              --file Ecom.Users/src/Ecom.Users.API/Dockerfile \
              --tag moclaw/ecom-users-api:latest \
              --load \
              --progress=plain \
              --no-cache-filter=build \
              .; then
              echo "Users API build successful on attempt $attempt"
              break
            else
              echo "Users API build failed on attempt $attempt"
              if [ $attempt -eq 3 ]; then
                echo "All attempts failed for Users API build"
                exit 1
              fi
              echo "Waiting 30 seconds before retry..."
              sleep 30
              
              # Clean up any partial builds
              docker buildx prune -f || true
            fi
          done
          
          echo "Verifying Users API image..."
          docker images | grep moclaw/ecom-users-api

      - name: Set up Minikube
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          container-runtime: docker
          
      - name: Load images to Minikube with verification
        run: |
          echo "Loading images to Minikube..."
          
          # Verify images exist locally first
          echo "Local Docker images:"
          docker images | grep moclaw
          
          # Load images with retry
          for image in "moclaw/ecom-core-api:latest" "moclaw/ecom-users-api:latest"; do
            echo "Loading $image..."
            for attempt in 1 2 3; do
              if minikube image load $image; then
                echo "$image loaded successfully"
                break
              else
                echo "Failed to load $image on attempt $attempt"
                if [ $attempt -eq 3 ]; then
                  echo "Failed to load $image after 3 attempts"
                  exit 1
                fi
                sleep 10
              fi
            done
          done
          
          echo "Verifying images are loaded in Minikube..."
          minikube image ls | grep moclaw || echo "No moclaw images found in Minikube"
          
          echo "All images in Minikube:"
          minikube image ls
          
      - name: Validate Kubernetes manifests
        run: |
          echo "Validating Kubernetes manifests..."
          
          # Check if files exist
          ls -la k8s/
          ls -la k8s/monitoring/
          
          # Validate YAML syntax
          echo "Validating namespace.yaml..."
          kubectl apply --dry-run=client -f k8s/namespace.yaml
          
          echo "Validating core-deployment.yaml..."
          kubectl apply --dry-run=client -f k8s/core-deployment.yaml
          
          echo "Validating users-deployment.yaml..."
          kubectl apply --dry-run=client -f k8s/users-deployment.yaml
          
          echo "Validating configmap.yaml..."
          kubectl apply --dry-run=client -f k8s/configmap.yaml
          
          echo "Validating prometheus-config.yaml..."
          kubectl apply --dry-run=client -f k8s/monitoring/prometheus-config.yaml

      - name: Deploy to Minikube
        run: |
          echo "Creating namespace..."
          kubectl apply -f k8s/namespace.yaml
          
          echo "Verifying namespace creation..."
          kubectl get namespace ecommerce
          sleep 5
          
          echo "Deploying applications..."
          kubectl apply -f k8s/core-deployment.yaml
          kubectl apply -f k8s/users-deployment.yaml
          kubectl apply -f k8s/configmap.yaml
          
          echo "Checking if deployments were created..."
          kubectl get deployments -n ecommerce
          
          echo "Checking initial pod status..."
          kubectl get pods -n ecommerce
          
      - name: Debug deployment issues
        run: |
          echo "=== DEBUGGING DEPLOYMENT ISSUES ==="
          
          echo "Checking deployment status..."
          kubectl get deployments -n ecommerce -o wide
          
          echo "Checking pods with detailed info..."
          kubectl get pods -n ecommerce -o wide
          
          echo "Describing ecom-core-api deployment..."
          kubectl describe deployment ecom-core-api -n ecommerce || echo "Core deployment not found"
          
          echo "Describing ecom-users-api deployment..."
          kubectl describe deployment ecom-users-api -n ecommerce || echo "Users deployment not found"
          
          echo "Checking events in ecommerce namespace..."
          kubectl get events -n ecommerce --sort-by='.lastTimestamp'
          
          echo "Checking if pods are stuck in ImagePull..."
          kubectl get pods -n ecommerce -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.phase}{"\t"}{.status.containerStatuses[0].state}{"\n"}{end}' || echo "No pods found"

      - name: Fix common deployment issues
        run: |
          echo "=== FIXING COMMON DEPLOYMENT ISSUES ==="
          
          # Wait a bit for initial deployment attempt
          sleep 30
          
          # Check for ImagePullBackOff or ErrImagePull issues
          echo "Checking for image pull issues..."
          kubectl get pods -n ecommerce
          
          FAILED_PODS=$(kubectl get pods -n ecommerce --field-selector=status.phase!=Running,status.phase!=Succeeded -o jsonpath='{.items[*].metadata.name}')
          
          if [ ! -z "$FAILED_PODS" ]; then
            echo "Found problematic pods: $FAILED_PODS"
            
            for pod in $FAILED_PODS; do
              echo "Describing pod $pod..."
              kubectl describe pod $pod -n ecommerce
              
              # Check if it's an image pull issue
              if kubectl get pod $pod -n ecommerce -o jsonpath='{.status.containerStatuses[0].state.waiting.reason}' | grep -E "(ImagePullBackOff|ErrImagePull)"; then
                echo "Pod $pod has image pull issues. Checking deployment imagePullPolicy..."
                
                # Get the deployment name from pod labels
                DEPLOYMENT=$(kubectl get pod $pod -n ecommerce -o jsonpath='{.metadata.labels.app}')
                if [ ! -z "$DEPLOYMENT" ]; then
                  echo "Patching deployment $DEPLOYMENT to use imagePullPolicy: Never for Minikube..."
                  kubectl patch deployment $DEPLOYMENT -n ecommerce -p '{"spec":{"template":{"spec":{"containers":[{"name":"'$DEPLOYMENT'","imagePullPolicy":"Never"}]}}}}'
                  
                  echo "Restarting deployment $DEPLOYMENT..."
                  kubectl rollout restart deployment/$DEPLOYMENT -n ecommerce
                fi
              fi
            done
          fi
          
          echo "Waiting for rollout to complete..."
          sleep 10

      - name: Configure external monitoring access
        run: |
          echo "Configuring access for external Prometheus and Grafana..."
          
          # Deploy external monitoring configuration
          kubectl apply -f k8s/monitoring/prometheus-config.yaml
          
          # Get Minikube IP for external access
          MINIKUBE_IP=$(minikube ip)
          echo "Minikube IP: $MINIKUBE_IP"
          
          echo "Services accessible from external Prometheus/Grafana:"
          echo "Core API metrics: http://$MINIKUBE_IP:30001/metrics"
          echo "Users API metrics: http://$MINIKUBE_IP:30002/metrics"
          
          # Test external access endpoints
          echo "Testing external monitoring endpoints..."
          sleep 30
          
          # Test if NodePort services are accessible
          kubectl get services -n ecommerce -o wide
          
          echo "=== PROMETHEUS CONFIGURATION ==="
          echo "Add these targets to your existing Prometheus configuration:"
          echo "- targets: ['$MINIKUBE_IP:30001'] # Core API"
          echo "- targets: ['$MINIKUBE_IP:30002'] # Users API"

      - name: Wait for monitoring stack
        run: |
          echo "Skipping internal monitoring deployment - using external Prometheus/Grafana"
          echo "Verifying external access configuration..."
          
          MINIKUBE_IP=$(minikube ip)
          echo "External monitoring endpoints:"
          echo "Core API: http://$MINIKUBE_IP:30001"
          echo "Users API: http://$MINIKUBE_IP:30002"
          
          # Test external endpoints
          curl -f http://$MINIKUBE_IP:30001/health || echo "Core API external endpoint not ready yet"
          curl -f http://$MINIKUBE_IP:30002/health || echo "Users API external endpoint not ready yet"

      - name: Test Service Health
        run: |
          echo "Testing service connectivity..."
          
          MINIKUBE_IP=$(minikube ip)
          
          # Test Core API via NodePort
          echo "Testing Core API via external endpoint..."
          curl -f http://$MINIKUBE_IP:30001/ || echo "Core API external access failed"
          
          # Test Users API via NodePort
          echo "Testing Users API via external endpoint..."
          curl -f http://$MINIKUBE_IP:30002/ || echo "Users API external access failed"
          
          # Test internal service connectivity
          kubectl port-forward -n ecommerce service/ecom-core-service 8080:80 &
          CORE_PID=$!
          sleep 10
          
          curl -f http://localhost:8080/ || echo "Core API internal connectivity failed"
          kill $CORE_PID || true
          
          kubectl port-forward -n ecommerce service/ecom-users-service 8081:80 &
          USERS_PID=$!
          sleep 10
          
          curl -f http://localhost:8081/ || echo "Users API internal connectivity failed"
          kill $USERS_PID || true
          
          echo "Service connectivity tests completed"
          echo "External monitoring available at:"
          echo "Core API: http://$MINIKUBE_IP:30001"
          echo "Users API: http://$MINIKUBE_IP:30002"
          
      - name: Verify deployment with extended timeout
        run: |
          echo "Waiting for deployments to be ready..."
          
          # Give deployments more time to start after potential fixes
          echo "Waiting 60 seconds for deployments to stabilize..."
          sleep 60
          
          # Check current status before waiting
          echo "Current deployment status:"
          kubectl get deployments -n ecommerce
          kubectl get pods -n ecommerce
          
          # Function to wait for deployment with better error handling
          wait_for_deployment() {
            local deployment_name=$1
            local app_label=$2
            
            echo "Waiting for $deployment_name deployment..."
            
            if kubectl get deployment $deployment_name -n ecommerce > /dev/null 2>&1; then
              # Check if deployment is progressing
              for i in {1..10}; do
                echo "Check $i/10: Deployment status..."
                kubectl get deployment $deployment_name -n ecommerce
                kubectl get pods -n ecommerce -l app=$app_label
                
                if kubectl wait --for=condition=available --timeout=60s deployment/$deployment_name -n ecommerce; then
                  echo "$deployment_name is ready!"
                  return 0
                fi
                
                echo "Still waiting for $deployment_name... Getting diagnostics..."
                kubectl describe deployment $deployment_name -n ecommerce
                kubectl get events -n ecommerce --field-selector involvedObject.name=$deployment_name
                
                # Get pod logs if available
                for pod in $(kubectl get pods -n ecommerce -l app=$app_label -o jsonpath='{.items[*].metadata.name}'); do
                  echo "Logs for pod $pod:"
                  kubectl logs $pod -n ecommerce --tail=20 || echo "No logs available for $pod"
                done
                
                sleep 30
              done
              
              echo "$deployment_name failed to become ready"
              return 1
            else
              echo "$deployment_name deployment not found!"
              return 1
            fi
          }
          
          # Wait for Core API
          wait_for_deployment "ecom-core-api" "ecom-core-api"
          
          # Wait for Users API
          wait_for_deployment "ecom-users-api" "ecom-users-api"
          
          echo "Final status check..."
          kubectl get pods -n ecommerce
          kubectl get services -n ecommerce