name: CI/CD Pipeline - Ecommerce Platform

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  DOTNET_VERSION: "9.0"
  REGISTRY_URL: ${{ secrets.REGISTRY_URL }}
  REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
  REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
  IMAGE_GATEWAY: moclaw/ecom-gateway-api
  IMAGE_CORE: moclaw/ecom-core-api
  IMAGE_USERS: moclaw/ecom-users-api
  HEALTH_CHECK_TIMEOUT: 180s

jobs:
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      should-deploy: ${{ steps.changes.outputs.should-deploy }}

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ” Check for changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Manual trigger - will deploy"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Main branch - will deploy"
          else
            if git diff --name-only HEAD~1 HEAD | grep -E "\\.(cs|csproj|sln|Dockerfile|yml|yaml)$"; then
              echo "should-deploy=true" >> $GITHUB_OUTPUT
              echo "Source code changes detected - will deploy"
            else
              echo "should-deploy=false" >> $GITHUB_OUTPUT
              echo "No significant changes - skipping deployment"
            fi
          fi

      - name: ğŸ”§ Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: ğŸ“¦ Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.props', '**/*.targets') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: ğŸ“¦ Restore dependencies
        run: |
          dotnet restore Moclaw.Ecommerce.sln --verbosity minimal

      - name: ğŸ—ï¸ Build solution
        run: |
          dotnet build Moclaw.Ecommerce.sln --configuration Release --no-restore --verbosity minimal

      - name: ğŸ§ª Run tests
        run: |
          if find . -name "*.Test*.csproj" -o -name "*Test.csproj" | head -1 | grep -q .; then
            echo "Running unit tests..."
            dotnet test --configuration Release --no-build --verbosity minimal --parallel
          else
            echo "No test projects found, skipping tests"
          fi

      - name: ğŸ·ï¸ Generate metadata
        id: meta
        run: |
          TAG="${{ github.sha }}"
          SHORT_SHA="${TAG:0:8}"
          echo "tags=${SHORT_SHA}" >> $GITHUB_OUTPUT

  build-images:
    name: Build Images
    runs-on: ubuntu-latest
    needs: build-and-test
    if: needs.build-and-test.outputs.should-deploy == 'true'
    strategy:
      matrix:
        service:
          - name: gateway-api
            dockerfile: Ecom.Gateway/src/Ecom.Gateway.API/Dockerfile
            image_name: moclaw/ecom-gateway-api
          - name: core-api
            dockerfile: Ecom.Core/src/Ecom.Core.API/Dockerfile
            image_name: moclaw/ecom-core-api
          - name: users-api
            dockerfile: Ecom.Users/src/Ecom.Users.API/Dockerfile
            image_name: moclaw/ecom-users-api
      fail-fast: false
      max-parallel: 3

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ” Login to Docker registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ env.REGISTRY_PASSWORD }}

      - name: ğŸ—ï¸ Build and push ${{ matrix.service.name }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: |
            ${{ matrix.service.image_name }}:${{ needs.build-and-test.outputs.image-tag }}
            ${{ matrix.service.image_name }}:latest
          platforms: linux/amd64
          cache-from: type=registry,ref=${{ matrix.service.image_name }}:buildcache
          cache-to: type=registry,ref=${{ matrix.service.image_name }}:buildcache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

  deploy-docker-compose:
    name: Deploy with Docker Compose
    runs-on: self-hosted
    needs: [build-and-test, build-images]
    if: needs.build-and-test.outputs.should-deploy == 'true'

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Login to Docker registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ env.REGISTRY_PASSWORD }}

      - name: ğŸ§¹ Pre-deployment cleanup
        run: |
          echo "ğŸ§¹ Starting pre-deployment cleanup..."

          # Show current port usage before cleanup
          echo "ğŸ“Š Current port usage before cleanup:"
          sudo netstat -tulpn | grep -E ':5300|:5301|:5302|:9090|:3000' || echo "No processes found on target ports"

          # Force stop and remove all containers with our project name
          echo "ğŸ›‘ Force stopping existing containers..."
          docker ps -a --filter "name=ecommerce" --format "{{.Names}}" | xargs -r docker stop --time=5 || true
          docker ps -a --filter "name=ecommerce" --format "{{.Names}}" | xargs -r docker rm -f || true

          # Also stop any containers that might be using our ports
          echo "ğŸ›‘ Stopping containers using target ports..."
          for port in 5300 5301 5302 9090 3000; do
            container_ids=$(docker ps --filter "publish=$port" --format "{{.ID}}" || true)
            if [ ! -z "$container_ids" ]; then
              echo "Stopping containers using port $port: $container_ids"
              echo "$container_ids" | xargs -r docker stop --time=5 || true
              echo "$container_ids" | xargs -r docker rm -f || true
            fi
          done

          # Clean up any existing docker-compose resources
          echo "ğŸ§¹ Cleaning up docker-compose resources..."
          docker-compose -f docker-compose.yml down --remove-orphans --volumes --timeout 30 || true

          # Remove any dangling containers
          echo "ğŸ§¹ Removing dangling containers..."
          docker container prune -f || true

          # Clean up networks that might conflict
          echo "ğŸŒ Cleaning up networks..."
          docker network ls --filter "name=ecommerce" --format "{{.Name}}" | xargs -r docker network rm || true
          docker network prune -f || true

          # Clean up volumes that might cause mount issues
          echo "ğŸ’¾ Cleaning up volumes..."
          docker volume ls --filter "name=ecommerce" --format "{{.Name}}" | xargs -r docker volume rm || true
          docker volume prune -f || true

          # More aggressive port cleanup
          echo "ğŸ”Œ Aggressive port cleanup..."
          for port in 5300 5301 5302 9090 3000; do
            echo "Force killing processes on port $port..."
            
            # Kill processes using lsof
            if sudo lsof -ti:$port 2>/dev/null; then
              echo "Found processes on port $port, killing them..."
              sudo lsof -ti:$port | xargs -r sudo kill -9 || true
            fi
            
            # Kill processes using netstat and kill
            pids=$(sudo netstat -tulpn | grep ":$port " | awk '{print $7}' | cut -d'/' -f1 | grep -v '-' || true)
            if [ ! -z "$pids" ]; then
              echo "Found additional PIDs on port $port: $pids"
              echo "$pids" | xargs -r sudo kill -9 || true
            fi
            
            # Kill processes using ss command as backup
            pids=$(sudo ss -tulpn | grep ":$port " | awk '{print $7}' | cut -d',' -f2 | cut -d'=' -f2 | grep -v '-' || true)
            if [ ! -z "$pids" ]; then
              echo "Found PIDs via ss on port $port: $pids"
              echo "$pids" | xargs -r sudo kill -9 || true
            fi
            
            sleep 1
          done

          # Wait longer for ports to be fully released
          echo "â³ Waiting for ports to be fully released..."
          sleep 10

          # Check for any remaining Docker processes that might interfere
          echo "ğŸ³ Checking for remaining Docker processes..."
          docker ps -a | grep -E "(ecommerce|gateway|core|users)" | awk '{print $1}' | tail -n +2 | xargs -r docker rm -f || true

          # Verify monitoring directory exists
          echo "ğŸ“ Verifying monitoring configuration..."
          if [ ! -f "monitoring/prometheus.yml" ]; then
            echo "âš ï¸ prometheus.yml not found, creating monitoring directory structure..."
            mkdir -p monitoring
            # Create a basic prometheus config if it doesn't exist
            cat > monitoring/prometheus.yml << 'EOF'
          global:
            scrape_interval: 15s
            evaluation_interval: 15s

          scrape_configs:
            - job_name: 'prometheus'
              static_configs:
                - targets: ['localhost:9090']
            
            - job_name: 'ecom-gateway'
              static_configs:
                - targets: ['ecom.gateway.api:5300']
              metrics_path: '/metrics'
              
            - job_name: 'ecom-core'
              static_configs:
                - targets: ['ecom.core.api:5301']
              metrics_path: '/metrics'
              
            - job_name: 'ecom-users'
              static_configs:
                - targets: ['ecom.users.api:5302']
              metrics_path: '/metrics'
          EOF
          fi

          # Final verification with multiple attempts
          echo "ğŸ” Final port verification..."
          for attempt in 1 2 3; do
            echo "Verification attempt $attempt/3..."
            all_ports_free=true
            
            for port in 5300 5301 5302 9090 3000; do
              if sudo lsof -ti:$port 2>/dev/null; then
                echo "âŒ Port $port is still in use on attempt $attempt!"
                sudo lsof -i:$port || true
                all_ports_free=false
                
                # Force kill again
                sudo lsof -ti:$port | xargs -r sudo kill -9 || true
              else
                echo "âœ… Port $port is available"
              fi
            done
            
            if [ "$all_ports_free" = true ]; then
              echo "âœ… All ports are now available"
              break
            fi
            
            if [ $attempt -lt 3 ]; then
              echo "â³ Waiting before next attempt..."
              sleep 5
            else
              echo "âŒ Some ports are still in use after 3 attempts!"
              echo "ğŸ“Š Current port usage:"
              sudo netstat -tulpn | grep -E ':5300|:5301|:5302|:9090|:3000' || true
              echo "ğŸ” Attempting to continue deployment anyway..."
            fi
          done

          echo "âœ… Pre-deployment cleanup completed"

      - name: ğŸš€ Deploy with Docker Compose
        env:
          GATEWAY_IMAGE: ${{ env.IMAGE_GATEWAY }}:${{ needs.build-and-test.outputs.image-tag }}
          CORE_IMAGE: ${{ env.IMAGE_CORE }}:${{ needs.build-and-test.outputs.image-tag }}
          USERS_IMAGE: ${{ env.IMAGE_USERS }}:${{ needs.build-and-test.outputs.image-tag }}
          IMAGE_TAG: ${{ needs.build-and-test.outputs.image-tag }}
        run: |
          set -e

          # Set error handling
          trap 'echo "âŒ Deployment failed at line $LINENO"' ERR

          echo "ğŸš€ Starting Docker Compose deployment..."
          echo "Gateway Image: $GATEWAY_IMAGE"
          echo "Core Image: $CORE_IMAGE"
          echo "Users Image: $USERS_IMAGE"

          # Function for retry logic
          retry_command() {
            local max_attempts=3
            local attempt=1
            local command="$1"
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $command"
              if eval "$command"; then
                return 0
              fi
              attempt=$((attempt + 1))
              [ $attempt -le $max_attempts ] && sleep 10
            done
            echo "Command failed after $max_attempts attempts: $command"
            return 1
          }

          # Pull latest images
          echo "ğŸ“¦ Pulling Docker images..."
          retry_command "docker pull $GATEWAY_IMAGE"
          retry_command "docker pull $CORE_IMAGE"
          retry_command "docker pull $USERS_IMAGE"

          # Set image tags in environment
          export DOCKER_REGISTRY=""
          export GATEWAY_TAG=$IMAGE_TAG
          export CORE_TAG=$IMAGE_TAG
          export USERS_TAG=$IMAGE_TAG

          # Create docker-compose override with specific image tags
          cat > docker-compose.override.yml << EOF
          version: '3.8'
          services:
            ecom.gateway.api:
              image: $GATEWAY_IMAGE
            ecom.core.api:
              image: $CORE_IMAGE
            ecom.users.api:
              image: $USERS_IMAGE
          EOF

          # Deploy services with better error handling
          echo "ğŸš€ Starting services with Docker Compose..."
          if ! docker-compose -f docker-compose.yml -f docker-compose.override.yml up -d --no-build; then
            echo "âŒ Docker Compose failed, checking logs..."
            docker-compose -f docker-compose.yml -f docker-compose.override.yml logs --tail=50
            exit 1
          fi

          # Wait for services to be healthy
          echo "â³ Waiting for services to be healthy..."
          timeout 300 bash -c '
            while true; do
              if docker-compose -f docker-compose.yml -f docker-compose.override.yml ps | grep -q "Up (healthy).*ecom.gateway.api" && \
                 docker-compose -f docker-compose.yml -f docker-compose.override.yml ps | grep -q "Up (healthy).*ecom.core.api" && \
                 docker-compose -f docker-compose.yml -f docker-compose.override.yml ps | grep -q "Up (healthy).*ecom.users.api"; then
                echo "âœ… All services are healthy"
                break
              fi
              echo "Waiting for services to be healthy..."
              docker-compose -f docker-compose.yml -f docker-compose.override.yml ps
              sleep 10
            done
          '

          # Enhanced health checks
          echo "ğŸ” Performing health checks..."

          health_check() {
            local url=$1
            local service_name=$2
            local max_attempts=15
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if curl -s --connect-timeout 5 --max-time 10 "$url" >/dev/null 2>&1; then
                echo "âœ… $service_name is healthy"
                return 0
              fi
              echo "Waiting for $service_name... (attempt $attempt/$max_attempts)"
              sleep 10
              attempt=$((attempt + 1))
            done
            echo "âš ï¸ $service_name health check timeout"
            return 1
          }

          # Perform health checks
          health_check "http://localhost:5300/health" "Gateway API" &
          health_check "http://localhost:5301/health" "Core API" &
          health_check "http://localhost:5302/health" "Users API" &
          wait

          # Display service status
          echo ""
          echo "ğŸš€ Deployment Complete!"
          echo "=================================="
          echo "Gateway API: http://localhost:5300"
          echo "Core API (via Gateway): http://localhost:5300/api/core"
          echo "Users API (via Gateway): http://localhost:5300/api/users"
          echo "Core API (Direct): http://localhost:5301"
          echo "Users API (Direct): http://localhost:5302"
          echo "Prometheus: http://localhost:9090"
          echo "Grafana: http://localhost:3000"
          echo "Image Tag: $IMAGE_TAG"
          echo ""
          echo "Service Status:"
          docker-compose -f docker-compose.yml -f docker-compose.override.yml ps

          # Cleanup old images to save space
          docker image prune -f --filter "until=24h" >/dev/null 2>&1 || true

      - name: ğŸ§¹ Enhanced Cleanup on failure
        if: failure()
        run: |
          echo "âŒ Deployment failed, starting comprehensive cleanup..."

          # Show what went wrong
          echo "ğŸ” Checking container logs..."
          docker-compose -f docker-compose.yml logs --tail=100 || true

          # Show current container status
          echo "ğŸ“Š Current container status:"
          docker ps -a

          # Show port usage
          echo "ğŸ”Œ Current port usage:"
          sudo netstat -tulpn | grep -E ':5300|:5301|:5302|:9090|:3000' || true

          # Nuclear cleanup - stop everything
          echo "ğŸ›‘ Nuclear cleanup - stopping everything..."
          
          # Stop all containers
          docker stop $(docker ps -aq) 2>/dev/null || true
          
          # Remove all containers with our project name
          docker ps -a --filter "name=ecommerce" --format "{{.Names}}" | xargs -r docker rm -f || true
          
          # Remove any containers using our ports
          for port in 5300 5301 5302 9090 3000; do
            container_ids=$(docker ps -a --filter "publish=$port" --format "{{.ID}}" || true)
            if [ ! -z "$container_ids" ]; then
              echo "Removing containers using port $port: $container_ids"
              echo "$container_ids" | xargs -r docker rm -f || true
            fi
          done

          # Stop and remove all containers using docker-compose
          docker-compose -f docker-compose.yml down --remove-orphans --volumes --timeout 30 || true

          # Remove any dangling containers
          echo "ğŸ§¹ Removing dangling containers..."
          docker container prune -f || true

          # Clean up networks
          echo "ğŸŒ Cleaning up networks..."
          docker network ls --filter "name=ecommerce" --format "{{.Name}}" | xargs -r docker network rm || true
          docker network prune -f || true

          # Clean up volumes
          echo "ğŸ’¾ Cleaning up volumes..."
          docker volume ls --filter "name=ecommerce" --format "{{.Name}}" | xargs -r docker volume rm -f || true
          docker volume prune -f || true

          # Ultra-aggressive port cleanup
          echo "ğŸ”Œ Ultra-aggressive port cleanup..."
          for port in 5300 5301 5302 9090 3000; do
            echo "Nuking everything on port $port..."
            
            # Kill with lsof
            sudo lsof -ti:$port 2>/dev/null | xargs -r sudo kill -9 || true
            
            # Kill with netstat
            sudo netstat -tulpn | grep ":$port " | awk '{print $7}' | cut -d'/' -f1 | grep -v '-' | xargs -r sudo kill -9 || true
            
            # Kill with ss
            sudo ss -tulpn | grep ":$port " | awk '{print $7}' | cut -d',' -f2 | cut -d'=' -f2 | grep -v '-' | xargs -r sudo kill -9 || true
            
            # Kill with fuser if available
            sudo fuser -k $port/tcp 2>/dev/null || true
          done

          # Remove unused images (more aggressive cleanup)
          echo "ğŸ–¼ï¸ Cleaning up images..."
          docker image prune -f --filter "until=1h" || true
          docker image prune -a -f --filter "label=org.opencontainers.image.title=ecom" || true

          # Remove build cache
          echo "ğŸ—„ï¸ Cleaning up build cache..."
          docker builder prune -f --filter "until=1h" || true

          # Clear temporary files
          echo "ğŸ“ Cleaning up temporary files..."
          rm -f docker-compose.override.yml || true

          # System cleanup
          echo "ğŸ§¹ System cleanup..."
          docker system prune -f --filter "until=1h" || true

          # Show disk usage after cleanup
          echo "ğŸ’¿ Disk usage after cleanup:"
          df -h

          # Show remaining Docker resources
          echo "ğŸ³ Remaining Docker resources:"
          docker system df

          # Final port check
          echo "ğŸ” Final port check:"
          for port in 5300 5301 5302 9090 3000; do
            if sudo lsof -ti:$port 2>/dev/null; then
              echo "âš ï¸ Port $port still in use:"
              sudo lsof -i:$port || true
            else
              echo "âœ… Port $port is now free"
            fi
          done

          echo "âœ… Comprehensive cleanup completed"
          echo "âŒ Deployment failed, cleanup executed"

  cleanup-resources:
    name: Cleanup Resources
    runs-on: self-hosted
    needs: [deploy-docker-compose]
    if: always() && needs.build-and-test.outputs.should-deploy == 'true'

    steps:
      - name: ğŸ§¹ Post-deployment cleanup
        run: |
          echo "ğŸ§¹ Starting post-deployment cleanup..."

          # Clean up old Docker images (keep last 3 versions)
          echo "ğŸ–¼ï¸ Cleaning up old images..."

          cleanup_old_images() {
            local image_name=$1
            echo "Cleaning up old versions of $image_name..."
            
            # Get all tags for the image, skip latest and current deployment
            docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" \
              | grep "^$image_name:" \
              | grep -v ":latest" \
              | grep -v ":${{ needs.build-and-test.outputs.image-tag }}" \
              | sort -k2 -r \
              | tail -n +4 \
              | awk '{print $1}' \
              | xargs -r docker rmi -f || true
          }

          cleanup_old_images "${{ env.IMAGE_GATEWAY }}"
          cleanup_old_images "${{ env.IMAGE_CORE }}"
          cleanup_old_images "${{ env.IMAGE_USERS }}"

          # Clean up dangling images and build cache
          echo "ğŸ—‘ï¸ Cleaning up dangling resources..."
          docker image prune -f --filter "until=24h" || true
          docker builder prune -f --filter "until=24h" || true

          # Clean up unused networks (keep active ones)
          echo "ğŸŒ Cleaning up unused networks..."
          docker network prune -f || true

          # Clean up temporary files
          echo "ğŸ“ Cleaning up temporary files..."
          rm -f docker-compose.override.yml || true

          # Show final system status
          echo "ğŸ“Š Final system status:"
          echo "Docker system usage:"
          docker system df
          echo ""
          echo "Disk usage:"
          df -h
          echo ""
          echo "Active containers:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

          echo "âœ… Post-deployment cleanup completed"

  notify-status:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [build-and-test, deploy-docker-compose, cleanup-resources]
    if: always() && needs.build-and-test.outputs.should-deploy == 'true'

    steps:
      - name: ğŸ“¢ Deployment Status Summary
        run: |
          echo "ğŸš€ Deployment Pipeline Summary"
          echo "=============================="
          echo "Build & Test: ${{ needs.build-and-test.result }}"
          echo "Deploy: ${{ needs.deploy-docker-compose.result }}"
          echo "Cleanup: ${{ needs.cleanup-resources.result }}"
          echo "Image Tag: ${{ needs.build-and-test.outputs.image-tag }}"
          echo ""

          if [ "${{ needs.deploy-docker-compose.result }}" = "success" ]; then
            echo "âœ… Deployment completed successfully!"
            echo "ğŸŒ Services are available at:"
            echo "  - Gateway API: http://localhost:5300"
            echo "  - Core API: http://localhost:5301"
            echo "  - Users API: http://localhost:5302"
          else
            echo "âŒ Deployment failed!"
            echo "ğŸ§¹ Resources have been cleaned up automatically"
            echo "ğŸ” Check the deployment logs for details"
          fi
