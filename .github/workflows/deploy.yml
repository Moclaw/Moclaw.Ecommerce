name: CI/CD Pipeline - Ecommerce Platform

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  DOTNET_VERSION: '9.0'
  REGISTRY_URL: ${{ secrets.REGISTRY_URL }}
  REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
  REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
  IMAGE_CORE: moclaw/ecom-core-api
  IMAGE_USERS: moclaw/ecom-users-api
  KUBE_NAMESPACE: ecommerce
  # SSH Connection via Cloudflare Tunnel
  CF_TUNNEL_HOST: ${{ secrets.CF_TUNNEL_HOST }}
  CF_TUNNEL_USER: ${{ secrets.CF_TUNNEL_USER }}
  SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
  CF_ACCESS_CLIENT_ID: ${{ secrets.CF_ACCESS_CLIENT_ID }}
  CF_ACCESS_CLIENT_SECRET: ${{ secrets.CF_ACCESS_CLIENT_SECRET }}
  # Optimization: Use shorter timeouts
  KUBECTL_TIMEOUT: 300s
  HEALTH_CHECK_TIMEOUT: 180s

jobs:
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîç Check for changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Manual trigger - will deploy"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Main branch - will deploy"
          else
            if git diff --name-only HEAD~1 HEAD | grep -E "\.(cs|csproj|sln|Dockerfile)$|^k8s/"; then
              echo "should-deploy=true" >> $GITHUB_OUTPUT
              echo "Source code changes detected - will deploy"
            else
              echo "should-deploy=false" >> $GITHUB_OUTPUT
              echo "No significant changes - skipping deployment"
            fi
          fi

      - name: üîß Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: üì¶ Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.props', '**/*.targets') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: üì¶ Restore dependencies
        run: |
          dotnet restore Moclaw.Ecommerce.sln --verbosity minimal

      - name: üèóÔ∏è Build solution
        run: |
          dotnet build Moclaw.Ecommerce.sln --configuration Release --no-restore --verbosity minimal

      - name: üß™ Run tests
        run: |
          if find . -name "*.Test*.csproj" -o -name "*Test.csproj" | head -1 | grep -q .; then
            echo "Running unit tests..."
            dotnet test --configuration Release --no-build --verbosity minimal --parallel
          else
            echo "No test projects found, skipping tests"
          fi

      - name: üè∑Ô∏è Generate metadata
        id: meta
        run: |
          TAG="${{ github.sha }}"
          SHORT_SHA="${TAG:0:8}"
          echo "tags=${SHORT_SHA}" >> $GITHUB_OUTPUT

  build-images:
    name: Build Images
    runs-on: ubuntu-latest
    needs: build-and-test
    if: needs.build-and-test.outputs.should-deploy == 'true'
    strategy:
      matrix:
        service:
          - name: core-api
            dockerfile: Ecom.Core/src/Ecom.Core.API/Dockerfile
            image_name: moclaw/ecom-core-api
          - name: users-api
            dockerfile: Ecom.Users/src/Ecom.Users.API/Dockerfile
            image_name: moclaw/ecom-users-api
      fail-fast: false
      max-parallel: 2

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to Docker registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ env.REGISTRY_PASSWORD }}

      - name: üèóÔ∏è Build and push ${{ matrix.service.name }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: |
            ${{ matrix.service.image_name }}:${{ needs.build-and-test.outputs.image-tag }}
            ${{ matrix.service.image_name }}:latest
          platforms: linux/amd64
          cache-from: type=registry,ref=${{ matrix.service.image_name }}:buildcache
          cache-to: type=registry,ref=${{ matrix.service.image_name }}:buildcache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

  deploy-minikube:
    name: Deploy via SSH
    runs-on: ubuntu-latest
    needs: [build-and-test, build-images]
    if: needs.build-and-test.outputs.should-deploy == 'true'
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      # Setup SSH connection through Cloudflare Tunnel
      - name: üîê Setup SSH
        run: |
          # Write SSH key to file using printf to handle special characters properly
          printf '%s\n' "$SSH_PRIVATE_KEY" > deploy_key
          chmod 600 deploy_key
          
          # Add Cloudflare Tunnel host to known_hosts
          ssh-keyscan -H "$CF_TUNNEL_HOST" >> known_hosts
          
          # Test SSH connection
          ssh -i deploy_key -o UserKnownHostsFile=known_hosts -o ConnectTimeout=10 -o StrictHostKeyChecking=no "$CF_TUNNEL_USER@$CF_TUNNEL_HOST" "echo 'SSH connection successful'"
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          CF_TUNNEL_HOST: ${{ secrets.CF_TUNNEL_HOST }}
          CF_TUNNEL_USER: ${{ secrets.CF_TUNNEL_USER }}

      # Transfer deployment files
      - name: üì§ Transfer deployment files
        run: |
          # Create deployment package
          tar -czf deployment.tar.gz k8s/ .github/scripts/ || tar -czf deployment.tar.gz k8s/
          
          # Transfer to remote server
          scp -i deploy_key -o UserKnownHostsFile=known_hosts -o StrictHostKeyChecking=no deployment.tar.gz "$CF_TUNNEL_USER@$CF_TUNNEL_HOST":~/
          
          # Extract on remote server
          ssh -i deploy_key -o UserKnownHostsFile=known_hosts -o StrictHostKeyChecking=no "$CF_TUNNEL_USER@$CF_TUNNEL_HOST" '
            rm -rf ~/deployment
            mkdir -p ~/deployment
            tar -xzf ~/deployment.tar.gz -C ~/deployment
            rm ~/deployment.tar.gz
          '
        env:
          CF_TUNNEL_HOST: ${{ secrets.CF_TUNNEL_HOST }}
          CF_TUNNEL_USER: ${{ secrets.CF_TUNNEL_USER }}

      # Remote deployment via SSH
      - name: üöÄ Deploy to Minikube (Remote)
        run: |
          ssh -i deploy_key -o UserKnownHostsFile=known_hosts -o StrictHostKeyChecking=no "$CF_TUNNEL_USER@$CF_TUNNEL_HOST" << 'EOF'
          set -e
          
          # Set environment variables
          export CORE_IMAGE="${{ env.IMAGE_CORE }}:${{ needs.build-and-test.outputs.image-tag }}"
          export USERS_IMAGE="${{ env.IMAGE_USERS }}:${{ needs.build-and-test.outputs.image-tag }}"
          export KUBE_NAMESPACE="${{ env.KUBE_NAMESPACE }}"
          export KUBECTL_TIMEOUT="${{ env.KUBECTL_TIMEOUT }}"
          
          echo "üöÄ Starting deployment on remote server..."
          echo "Core Image: $CORE_IMAGE"
          echo "Users Image: $USERS_IMAGE"
          
          # Check/Start Minikube
          echo "Checking Minikube status..."
          if minikube status 2>/dev/null | grep -q "host: Running" && kubectl cluster-info 2>/dev/null; then
            echo "‚úÖ Minikube cluster is healthy"
            MINIKUBE_IP=$(minikube ip)
          else
            echo "Starting Minikube cluster..."
            minikube delete 2>/dev/null || true
            minikube start \
              --driver=docker \
              --kubernetes-version=v1.28.3 \
              --memory=4096 \
              --cpus=2 \
              --disk-size=15g \
              --wait=all
            
            minikube addons enable ingress
            kubectl wait --for=condition=Ready nodes --all --timeout=180s
            MINIKUBE_IP=$(minikube ip)
          fi
          
          echo "Minikube IP: $MINIKUBE_IP"
          
          # Login to Docker registry and pull images
          echo "Logging into Docker registry..."
          echo "${{ env.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY_URL }} -u "${{ env.REGISTRY_USERNAME }}" --password-stdin
          
          # Pull and load images
          echo "Loading Docker images..."
          if ! minikube image ls | grep -q "${{ needs.build-and-test.outputs.image-tag }}"; then
            echo "Pulling new images..."
            docker pull "$CORE_IMAGE" &
            docker pull "$USERS_IMAGE" &
            wait
            
            minikube image load "$CORE_IMAGE" &
            minikube image load "$USERS_IMAGE" &
            wait
            echo "‚úÖ Images loaded"
          else
            echo "‚úÖ Images already present"
          fi
          
          # Deploy Kubernetes resources
          echo "Deploying Kubernetes resources..."
          cd ~/deployment
          
          # Create namespace
          kubectl create namespace $KUBE_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          
          # Apply base configurations
          kubectl apply -f k8s/secrets.yaml -n $KUBE_NAMESPACE
          kubectl apply -f k8s/configmap.yaml -n $KUBE_NAMESPACE
          
          # Deploy PostgreSQL if not exists
          if ! kubectl get deployment postgres -n $KUBE_NAMESPACE 2>/dev/null; then
            kubectl apply -f k8s/postgres/deployment.yaml -n $KUBE_NAMESPACE
          fi
          
          # Deploy APIs
          kubectl apply -f k8s/core-api/ -n $KUBE_NAMESPACE
          kubectl apply -f k8s/users-api/ -n $KUBE_NAMESPACE
          
          # Update images
          kubectl set image deployment/core-api core-api=$CORE_IMAGE -n $KUBE_NAMESPACE
          kubectl set image deployment/users-api users-api=$USERS_IMAGE -n $KUBE_NAMESPACE
          
          # Fix environment configurations
          kubectl patch deployment core-api -n $KUBE_NAMESPACE --type='merge' -p='{
            "spec": {
              "template": {
                "spec": {
                  "containers": [{
                    "name": "core-api",
                    "env": [
                      {"name": "ASPNETCORE_ENVIRONMENT", "value": "Production"},
                      {"name": "ASPNETCORE_URLS", "value": "http://+:8080"}
                    ]
                  }]
                }
              }
            }
          }' || echo "Patch already applied"
          
          kubectl patch deployment users-api -n $KUBE_NAMESPACE --type='merge' -p='{
            "spec": {
              "template": {
                "spec": {
                  "containers": [{
                    "name": "users-api",
                    "env": [
                      {"name": "ASPNETCORE_ENVIRONMENT", "value": "Production"},
                      {"name": "ASPNETCORE_URLS", "value": "http://+:8080"}
                    ]
                  }]
                }
              }
            }
          }' || echo "Patch already applied"
          
          # Wait for deployments
          echo "Waiting for deployments..."
          
          # Wait for PostgreSQL if new
          if ! kubectl get pods -l app=postgres -n $KUBE_NAMESPACE -o jsonpath='{.items[0].status.phase}' 2>/dev/null | grep -q "Running"; then
            kubectl rollout status deployment/postgres -n $KUBE_NAMESPACE --timeout=$KUBECTL_TIMEOUT
          fi
          
          # Wait for APIs
          kubectl rollout status deployment/core-api -n $KUBE_NAMESPACE --timeout=$KUBECTL_TIMEOUT &
          kubectl rollout status deployment/users-api -n $KUBE_NAMESPACE --timeout=$KUBECTL_TIMEOUT &
          wait
          
          echo "‚úÖ All deployments ready!"
          
          # Quick health check
          echo "Performing health checks..."
          timeout 30s bash -c '
            until curl -s http://'$MINIKUBE_IP':30301/ >/dev/null 2>&1; do 
              echo "Waiting for Core API..."
              sleep 2
            done
          ' && echo "‚úÖ Core API ready" || echo "‚ö†Ô∏è Core API timeout"
          
          timeout 30s bash -c '
            until curl -s http://'$MINIKUBE_IP':30302/ >/dev/null 2>&1; do 
              echo "Waiting for Users API..."
              sleep 2
            done
          ' && echo "‚úÖ Users API ready" || echo "‚ö†Ô∏è Users API timeout"
          
          # Summary
          echo "üöÄ Deployment Complete!"
          echo "Core API: http://$MINIKUBE_IP:30301"
          echo "Users API: http://$MINIKUBE_IP:30302"
          echo "Image Tag: ${{ needs.build-and-test.outputs.image-tag }}"
          
          kubectl get pods -n $KUBE_NAMESPACE --no-headers | awk '{print $1": "$3}'
          
          EOF
        env:
          CF_TUNNEL_HOST: ${{ secrets.CF_TUNNEL_HOST }}
          CF_TUNNEL_USER: ${{ secrets.CF_TUNNEL_USER }}
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
          REGISTRY_URL: ${{ secrets.REGISTRY_URL }}
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}

      # Cleanup SSH
      - name: üßπ Cleanup SSH
        if: always()
        run: |
          rm -f deploy_key known_hosts
          
      # Cleanup on failure
      - name: üßπ Remote cleanup on failure
        if: failure()
        run: |
          ssh -i deploy_key -o UserKnownHostsFile=known_hosts -o StrictHostKeyChecking=no "$CF_TUNNEL_USER@$CF_TUNNEL_HOST" '
            kubectl delete pods --field-selector=status.phase=Failed -n $KUBE_NAMESPACE --ignore-not-found=true
            docker system prune -f --filter "until=1h" || true
            rm -rf ~/deployment
          ' || echo "Remote cleanup failed"
        env:
          CF_TUNNEL_HOST: ${{ secrets.CF_TUNNEL_HOST }}
          CF_TUNNEL_USER: ${{ secrets.CF_TUNNEL_USER }}
          KUBE_NAMESPACE: ${{ env.KUBE_NAMESPACE }}
