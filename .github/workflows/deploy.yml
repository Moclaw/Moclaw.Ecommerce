name: CI/CD Pipeline - Ecommerce Platform

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  DOTNET_VERSION: '9.0'
  REGISTRY_URL: ${{ secrets.REGISTRY_URL }}
  REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
  REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
  IMAGE_CORE: moclaw/ecom-core-api
  IMAGE_USERS: moclaw/ecom-users-api
  KUBE_NAMESPACE: ecommerce
  # Optimization: Use shorter timeouts
  KUBECTL_TIMEOUT: 300s
  HEALTH_CHECK_TIMEOUT: 180s

jobs:
  build-and-test:
    name: Build & Test
    runs-on: self-hosted
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Optimization: Check for changes to skip unnecessary builds
      - name: üîç Check for changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Manual trigger - will deploy"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Main branch - will deploy"
          else
            # Check if there are changes in source code directories
            if git diff --name-only HEAD~1 HEAD | grep -E "\.(cs|csproj|sln|Dockerfile)$|^k8s/"; then
              echo "should-deploy=true" >> $GITHUB_OUTPUT
              echo "Source code changes detected - will deploy"
            else
              echo "should-deploy=false" >> $GITHUB_OUTPUT
              echo "No significant changes - skipping deployment"
            fi
          fi

      # Optimization: Lightweight cleanup
      - name: üßπ Quick cleanup
        run: |
          # Only clean what's necessary
          docker system prune -f --filter "until=24h" || true
          pkill -f "dotnet.*Ecom" || true

      - name: üîß Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          cache: true

      - name: üì¶ Restore dependencies
        run: |
          dotnet restore Moclaw.Ecommerce.sln --verbosity minimal --no-cache

      - name: üèóÔ∏è Build solution
        run: |
          dotnet build Moclaw.Ecommerce.sln --configuration Release --no-restore --verbosity minimal

      # Optimization: Parallel unit tests if they exist
      - name: üß™ Run tests
        run: |
          if find . -name "*.Test*.csproj" -o -name "*Test.csproj" | head -1 | grep -q .; then
            echo "Running unit tests..."
            dotnet test --configuration Release --no-build --verbosity minimal --parallel
          else
            echo "No test projects found, skipping tests"
          fi

      - name: üè∑Ô∏è Generate metadata
        id: meta
        run: |
          # Optimization: Use short SHA for faster image operations
          TAG="${{ github.sha }}"
          SHORT_SHA="${TAG:0:8}"
          echo "tags=${SHORT_SHA}" >> $GITHUB_OUTPUT

  build-images:
    name: Build Images
    runs-on: self-hosted
    needs: build-and-test
    if: needs.build-and-test.outputs.should-deploy == 'true'
    strategy:
      matrix:
        service:
          - name: core-api
            dockerfile: Ecom.Core/src/Ecom.Core.API/Dockerfile
            image_name: moclaw/ecom-core-api
          - name: users-api
            dockerfile: Ecom.Users/src/Ecom.Users.API/Dockerfile
            image_name: moclaw/ecom-users-api
      fail-fast: false
      # Optimization: Build images in parallel but limit concurrency
      max-parallel: 2

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host

      - name: üîê Login to Docker registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ env.REGISTRY_PASSWORD }}

      # Optimization: Use cache and multi-stage builds
      - name: üèóÔ∏è Build and push ${{ matrix.service.name }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: |
            ${{ matrix.service.image_name }}:${{ needs.build-and-test.outputs.image-tag }}
            ${{ matrix.service.image_name }}:latest
          platforms: linux/amd64
          cache-from: type=registry,ref=${{ matrix.service.image_name }}:buildcache
          cache-to: type=registry,ref=${{ matrix.service.image_name }}:buildcache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

  deploy-minikube:
    name: Deploy
    runs-on: self-hosted
    needs: [build-and-test, build-images]
    if: needs.build-and-test.outputs.should-deploy == 'true'
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      # Optimization: Reuse existing minikube cluster if healthy
      - name: üöÄ Setup/Reuse Minikube
        run: |
          echo "Checking existing Minikube cluster..."
          
          if minikube status 2>/dev/null | grep -q "host: Running" && kubectl cluster-info 2>/dev/null; then
            echo "‚úÖ Existing Minikube cluster is healthy, reusing it"
            MINIKUBE_IP=$(minikube ip)
            echo "Minikube IP: $MINIKUBE_IP"
          else
            echo "Starting new Minikube cluster..."
            
            # Quick cleanup
            minikube delete 2>/dev/null || true
            
            # Optimization: Smaller resource allocation for faster startup
            minikube start \
              --driver=docker \
              --kubernetes-version=v1.28.3 \
              --memory=4096 \
              --cpus=2 \
              --disk-size=15g \
              --wait=all \
              --force
            
            # Enable only necessary addons
            minikube addons enable ingress
            
            kubectl wait --for=condition=Ready nodes --all --timeout=180s
          fi

      # Optimization: Skip image loading if already present
      - name: üîÑ Load Docker images
        run: |
          CORE_IMAGE="${{ env.IMAGE_CORE }}:${{ needs.build-and-test.outputs.image-tag }}"
          USERS_IMAGE="${{ env.IMAGE_USERS }}:${{ needs.build-and-test.outputs.image-tag }}"
          
          echo "Checking if images exist in Minikube..."
          
          # Check if images already exist
          if minikube image ls | grep -q "${{ needs.build-and-test.outputs.image-tag }}"; then
            echo "‚úÖ Images already loaded in Minikube"
          else
            echo "Loading new images..."
            docker pull "$CORE_IMAGE" &
            docker pull "$USERS_IMAGE" &
            wait
            
            minikube image load "$CORE_IMAGE" &
            minikube image load "$USERS_IMAGE" &
            wait
          fi

      # Optimization: Smart deployment with rolling updates
      - name: üèóÔ∏è Deploy Kubernetes resources
        run: |
          CORE_IMAGE="${{ env.IMAGE_CORE }}:${{ needs.build-and-test.outputs.image-tag }}"
          USERS_IMAGE="${{ env.IMAGE_USERS }}:${{ needs.build-and-test.outputs.image-tag }}"
          
          # Create namespace if not exists
          kubectl create namespace ${{ env.KUBE_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Apply configurations in dependency order
          echo "Applying base configurations..."
          kubectl apply -f k8s/secrets.yaml -n ${{ env.KUBE_NAMESPACE }}
          kubectl apply -f k8s/configmap.yaml -n ${{ env.KUBE_NAMESPACE }}
          
          # Deploy PostgreSQL first (if not already running)
          if ! kubectl get deployment postgres -n ${{ env.KUBE_NAMESPACE }} 2>/dev/null; then
            kubectl apply -f k8s/postgres/deployment.yaml -n ${{ env.KUBE_NAMESPACE }}
          fi
          
          # Apply services and deployments
          kubectl apply -f k8s/core-api/ -n ${{ env.KUBE_NAMESPACE }}
          kubectl apply -f k8s/users-api/ -n ${{ env.KUBE_NAMESPACE }}
          
          # Update images with rolling restart
          kubectl set image deployment/core-api core-api=$CORE_IMAGE -n ${{ env.KUBE_NAMESPACE }}
          kubectl set image deployment/users-api users-api=$USERS_IMAGE -n ${{ env.KUBE_NAMESPACE }}
          
          # Optimization: Apply environment fixes only once
          kubectl patch deployment core-api -n ${{ env.KUBE_NAMESPACE }} --type='merge' -p='{
            "spec": {
              "template": {
                "spec": {
                  "containers": [{
                    "name": "core-api",
                    "env": [
                      {"name": "ASPNETCORE_ENVIRONMENT", "value": "Production"},
                      {"name": "ASPNETCORE_URLS", "value": "http://+:8080"}
                    ]
                  }]
                }
              }
            }
          }' || echo "Patch already applied or failed"

      # Optimization: Faster deployment checks
      - name: ‚è≥ Wait for deployments
        run: |
          echo "Waiting for deployments..."
          
          # Wait for PostgreSQL (only if it's new)
          if ! kubectl get pods -l app=postgres -n ${{ env.KUBE_NAMESPACE }} -o jsonpath='{.items[0].status.phase}' 2>/dev/null | grep -q "Running"; then
            kubectl rollout status deployment/postgres -n ${{ env.KUBE_NAMESPACE }} --timeout=${{ env.KUBECTL_TIMEOUT }}
          fi
          
          # Wait for APIs in parallel
          kubectl rollout status deployment/core-api -n ${{ env.KUBE_NAMESPACE }} --timeout=${{ env.KUBECTL_TIMEOUT }} &
          kubectl rollout status deployment/users-api -n ${{ env.KUBE_NAMESPACE }} --timeout=${{ env.KUBECTL_TIMEOUT }} &
          wait
          
          echo "‚úÖ All deployments ready!"

      # Optimization: Quick health check
      - name: ü©∫ Quick health check
        run: |
          MINIKUBE_IP=$(minikube ip)
          
          # Quick connectivity test (max 30 seconds total)
          timeout 30s bash -c '
            until curl -s http://'$MINIKUBE_IP':30301/ >/dev/null 2>&1; do 
              echo "Waiting for Core API..."
              sleep 2
            done
          ' && echo "‚úÖ Core API ready" || echo "‚ö†Ô∏è Core API timeout"
          
          timeout 30s bash -c '
            until curl -s http://'$MINIKUBE_IP':30302/ >/dev/null 2>&1; do 
              echo "Waiting for Users API..."
              sleep 2
            done
          ' && echo "‚úÖ Users API ready" || echo "‚ö†Ô∏è Users API timeout"

      # Optimization: Concise summary
      - name: üìä Deployment summary
        run: |
          MINIKUBE_IP=$(minikube ip)
          echo "üöÄ Deployment Complete!"
          echo "Core API: http://$MINIKUBE_IP:30301"
          echo "Users API: http://$MINIKUBE_IP:30302"
          echo "Image Tag: ${{ needs.build-and-test.outputs.image-tag }}"
          
          # Show only essential status
          kubectl get pods -n ${{ env.KUBE_NAMESPACE }} --no-headers | awk '{print $1": "$3}'

      # Optimization: Minimal cleanup
      - name: üßπ Cleanup on failure
        if: failure()
        run: |
          echo "Minimal cleanup after failure..."
          kubectl delete pods --field-selector=status.phase=Failed -n ${{ env.KUBE_NAMESPACE }} --ignore-not-found=true
          docker system prune -f --filter "until=1h" || true
