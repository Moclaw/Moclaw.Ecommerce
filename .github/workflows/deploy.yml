name: CI/CD for Minikube

on:
  push:
    branches: [ main ]


jobs:
  build-and-deploy:
    runs-on: self-hosted
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup .NET with proper permissions
        run: |
          echo "Setting up .NET for self-hosted runner..."
          
          # Check if .NET is already installed
          if command -v dotnet &> /dev/null; then
            echo ".NET is already installed:"
            dotnet --version
            dotnet --list-sdks
          else
            echo "Installing .NET manually..."
            
            # Create local dotnet directory
            mkdir -p $HOME/.dotnet
            export DOTNET_ROOT=$HOME/.dotnet
            export PATH=$DOTNET_ROOT:$PATH
            
            # Download and install .NET
            curl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --channel 9.0 --install-dir $HOME/.dotnet
            
            # Add to PATH for subsequent steps
            echo "DOTNET_ROOT=$HOME/.dotnet" >> $GITHUB_ENV
            echo "$HOME/.dotnet" >> $GITHUB_PATH
            
            echo "Verifying installation:"
            $HOME/.dotnet/dotnet --version
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build Core API Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: Ecom.Core/src/Ecom.Core.API/Dockerfile
          push: false
          load: true
          tags: moclaw/ecom-core-api:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build Users API Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: Ecom.Users/src/Ecom.Users.API/Dockerfile
          push: false
          load: true
          tags: moclaw/ecom-users-api:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set up Minikube
        uses: medyagh/setup-minikube@latest

      - name: Load images to Minikube
        run: |
          echo "Loading images to Minikube..."
          minikube image load moclaw/ecom-core-api:latest
          minikube image load moclaw/ecom-users-api:latest
          
          echo "Verifying images are loaded in Minikube..."
          minikube image ls | grep moclaw || echo "No moclaw images found"
          
          echo "All images in Minikube:"
          minikube image ls
          
      - name: Validate Kubernetes manifests
        run: |
          echo "Validating Kubernetes manifests..."
          
          # Check if files exist
          ls -la k8s/
          ls -la k8s/monitoring/
          
          # Validate YAML syntax
          echo "Validating namespace.yaml..."
          kubectl apply --dry-run=client -f k8s/namespace.yaml
          
          echo "Validating core-deployment.yaml..."
          kubectl apply --dry-run=client -f k8s/core-deployment.yaml
          
          echo "Validating users-deployment.yaml..."
          kubectl apply --dry-run=client -f k8s/users-deployment.yaml
          
          echo "Validating configmap.yaml..."
          kubectl apply --dry-run=client -f k8s/configmap.yaml
          
          echo "Validating prometheus-config.yaml..."
          kubectl apply --dry-run=client -f k8s/monitoring/prometheus-config.yaml

      - name: Deploy to Minikube
        run: |
          echo "Creating namespace..."
          kubectl apply -f k8s/namespace.yaml
          
          echo "Verifying namespace creation..."
          kubectl get namespace ecommerce
          sleep 5
          
          echo "Deploying applications..."
          kubectl apply -f k8s/core-deployment.yaml
          kubectl apply -f k8s/users-deployment.yaml
          kubectl apply -f k8s/configmap.yaml
          
          echo "Checking if deployments were created..."
          kubectl get deployments -n ecommerce
          
          echo "Checking initial pod status..."
          kubectl get pods -n ecommerce
          
      - name: Debug deployment issues
        run: |
          echo "=== DEBUGGING DEPLOYMENT ISSUES ==="
          
          echo "Checking deployment status..."
          kubectl get deployments -n ecommerce -o wide
          
          echo "Checking pods with detailed info..."
          kubectl get pods -n ecommerce -o wide
          
          echo "Describing ecom-core-api deployment..."
          kubectl describe deployment ecom-core-api -n ecommerce || echo "Core deployment not found"
          
          echo "Describing ecom-users-api deployment..."
          kubectl describe deployment ecom-users-api -n ecommerce || echo "Users deployment not found"
          
          echo "Checking events in ecommerce namespace..."
          kubectl get events -n ecommerce --sort-by='.lastTimestamp'
          
          echo "Checking if pods are stuck in ImagePull..."
          kubectl get pods -n ecommerce -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.phase}{"\t"}{.status.containerStatuses[0].state}{"\n"}{end}' || echo "No pods found"

      - name: Fix common deployment issues
        run: |
          echo "=== FIXING COMMON DEPLOYMENT ISSUES ==="
          
          # Wait a bit for initial deployment attempt
          sleep 30
          
          # Check for ImagePullBackOff or ErrImagePull issues
          echo "Checking for image pull issues..."
          kubectl get pods -n ecommerce
          
          FAILED_PODS=$(kubectl get pods -n ecommerce --field-selector=status.phase!=Running,status.phase!=Succeeded -o jsonpath='{.items[*].metadata.name}')
          
          if [ ! -z "$FAILED_PODS" ]; then
            echo "Found problematic pods: $FAILED_PODS"
            
            for pod in $FAILED_PODS; do
              echo "Describing pod $pod..."
              kubectl describe pod $pod -n ecommerce
              
              # Check if it's an image pull issue
              if kubectl get pod $pod -n ecommerce -o jsonpath='{.status.containerStatuses[0].state.waiting.reason}' | grep -E "(ImagePullBackOff|ErrImagePull)"; then
                echo "Pod $pod has image pull issues. Checking deployment imagePullPolicy..."
                
                # Get the deployment name from pod labels
                DEPLOYMENT=$(kubectl get pod $pod -n ecommerce -o jsonpath='{.metadata.labels.app}')
                if [ ! -z "$DEPLOYMENT" ]; then
                  echo "Patching deployment $DEPLOYMENT to use imagePullPolicy: Never for Minikube..."
                  kubectl patch deployment $DEPLOYMENT -n ecommerce -p '{"spec":{"template":{"spec":{"containers":[{"name":"'$DEPLOYMENT'","imagePullPolicy":"Never"}]}}}}'
                  
                  echo "Restarting deployment $DEPLOYMENT..."
                  kubectl rollout restart deployment/$DEPLOYMENT -n ecommerce
                fi
              fi
            done
          fi
          
          echo "Waiting for rollout to complete..."
          sleep 10

      - name: Configure external monitoring access
        run: |
          echo "Configuring access for external Prometheus and Grafana..."
          
          # Deploy external monitoring configuration
          kubectl apply -f k8s/monitoring/prometheus-config.yaml
          
          # Get Minikube IP for external access
          MINIKUBE_IP=$(minikube ip)
          echo "Minikube IP: $MINIKUBE_IP"
          
          echo "Services accessible from external Prometheus/Grafana:"
          echo "Core API metrics: http://$MINIKUBE_IP:30001/metrics"
          echo "Users API metrics: http://$MINIKUBE_IP:30002/metrics"
          
          # Test external access endpoints
          echo "Testing external monitoring endpoints..."
          sleep 30
          
          # Test if NodePort services are accessible
          kubectl get services -n ecommerce -o wide
          
          echo "=== PROMETHEUS CONFIGURATION ==="
          echo "Add these targets to your existing Prometheus configuration:"
          echo "- targets: ['$MINIKUBE_IP:30001'] # Core API"
          echo "- targets: ['$MINIKUBE_IP:30002'] # Users API"

      - name: Wait for monitoring stack
        run: |
          echo "Skipping internal monitoring deployment - using external Prometheus/Grafana"
          echo "Verifying external access configuration..."
          
          MINIKUBE_IP=$(minikube ip)
          echo "External monitoring endpoints:"
          echo "Core API: http://$MINIKUBE_IP:30001"
          echo "Users API: http://$MINIKUBE_IP:30002"
          
          # Test external endpoints
          curl -f http://$MINIKUBE_IP:30001/health || echo "Core API external endpoint not ready yet"
          curl -f http://$MINIKUBE_IP:30002/health || echo "Users API external endpoint not ready yet"

      - name: Test Service Health
        run: |
          echo "Testing service connectivity..."
          
          MINIKUBE_IP=$(minikube ip)
          
          # Test Core API via NodePort
          echo "Testing Core API via external endpoint..."
          curl -f http://$MINIKUBE_IP:30001/ || echo "Core API external access failed"
          
          # Test Users API via NodePort
          echo "Testing Users API via external endpoint..."
          curl -f http://$MINIKUBE_IP:30002/ || echo "Users API external access failed"
          
          # Test internal service connectivity
          kubectl port-forward -n ecommerce service/ecom-core-service 8080:80 &
          CORE_PID=$!
          sleep 10
          
          curl -f http://localhost:8080/ || echo "Core API internal connectivity failed"
          kill $CORE_PID || true
          
          kubectl port-forward -n ecommerce service/ecom-users-service 8081:80 &
          USERS_PID=$!
          sleep 10
          
          curl -f http://localhost:8081/ || echo "Users API internal connectivity failed"
          kill $USERS_PID || true
          
          echo "Service connectivity tests completed"
          echo "External monitoring available at:"
          echo "Core API: http://$MINIKUBE_IP:30001"
          echo "Users API: http://$MINIKUBE_IP:30002"