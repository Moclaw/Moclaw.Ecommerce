name: CI/CD for Docker Compose and Minikube

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: self-hosted

    steps:
      # 1) Pre-clean the entire repo directory (including root-owned bits)
      - name: Pre-clean workspace
        run: |
          echo "ðŸš§ Removing stale workspaceâ€¦"
          sudo rm -rf "${{ runner.workspace }}/${{ github.repository }}" || true

      # 2) Checkout code
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          clean: true

      # 3) Fix any lingering permission issues
      - name: Fix workspace permissions
        run: |
          echo "ðŸ”§ Fixing permissionsâ€¦"
          sudo chown -R "$(id -u):$(id -g)" "$GITHUB_WORKSPACE" || true
          sudo chmod -R 755 "$GITHUB_WORKSPACE" || true

      # 4) Setup .NET (install if missing)
      - name: Setup .NET with proper permissions
        run: |
          echo "Setting up .NET for self-hosted runnerâ€¦"
          if command -v dotnet &> /dev/null; then
            echo ".NET already installed:"
            dotnet --version
            dotnet --list-sdks
          else
            echo "Installing .NETâ€¦"
            mkdir -p "$HOME/.dotnet"
            export DOTNET_ROOT="$HOME/.dotnet"
            export PATH="$DOTNET_ROOT:$PATH"
            curl -sSL https://dot.net/v1/dotnet-install.sh \
              | bash /dev/stdin --channel 9.0 --install-dir "$HOME/.dotnet"
            echo "DOTNET_ROOT=$HOME/.dotnet" >> "$GITHUB_ENV"
            echo "$HOME/.dotnet" >> "$GITHUB_PATH"
            echo "Installed .NET version:"
            "$HOME/.dotnet/dotnet" --version
          fi

      # 5) Clean up existing Docker containers, volumes, ports
      - name: Comprehensive cleanup of existing containers and ports
        run: |
          echo "ðŸ§¹ Cleaning up Dockerâ€¦"
          docker compose down --remove-orphans || true
          docker compose -f docker-compose.yml -f docker-compose.prod.yml down --remove-orphans || true
          docker volume ls | grep -E "(grafana|prometheus)" | awk '{print $2}' | xargs -r docker volume rm --force || true
          for port in 5301 5302 9090 3000 5401 5402 9091 3001; do
            sudo lsof -ti:$port | xargs -r sudo kill -9 || true
          done
          docker system prune -f || true

      # 6) Create monitoring config directory & prometheus.yml
      - name: Create monitoring configuration
        run: |
          echo "âš™ï¸  Writing Prometheus configâ€¦"
          mkdir -p monitoring
          cat > monitoring/prometheus.yml << 'EOF'
          global:
            scrape_interval: 15s
            evaluation_interval: 15s
            external_labels:
              monitor: 'ecommerce-monitor'

          scrape_configs:
            - job_name: 'prometheus'
              static_configs:
                - targets: ['localhost:9090']

            - job_name: 'ecom-core-api'
              static_configs:
                - targets: ['ecom.core.api:8080']
              metrics_path: '/metrics'
              scrape_interval: 30s

            - job_name: 'ecom-users-api'
              static_configs:
                - targets: ['ecom.users.api:8080']
              metrics_path: '/metrics'
              scrape_interval: 30s
          EOF
          chmod 644 monitoring/prometheus.yml

      # 7) Enable Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          driver-opts: |
            network=host

      # 8) Build & test via Docker Compose in CI mode
      - name: Build and test with Docker Compose (CI Environment)
        run: |
          echo "ðŸ”¨ Building services (CI)â€¦"
          CI_CORE_PORT=$(python3 - <<<'import socket; s=socket.socket(); s.bind(("",0)); print(s.getsockname()[1]); s.close()')
          CI_USERS_PORT=$(python3 - <<<'import socket; s=socket.socket(); s.bind(("",0)); print(s.getsockname()[1]); s.close()')
          CI_PROM_PORT=$(python3 - <<<'import socket; s=socket.socket(); s.bind(("",0)); print(s.getsockname()[1]); s.close()')
          CI_GF_PORT=$(python3 - <<<'import socket; s=socket.socket(); s.bind(("",0)); print(s.getsockname()[1]); s.close()')
          cat > docker-compose.ci.yml << EOF
          version: '3.8'
          services:
            ecom.core.api:
              build:
                context: .
                dockerfile: Ecom.Core/src/Ecom.Core.API/Dockerfile
                args:
                  BUILDKIT_INLINE_CACHE: 1
              ports:
                - "${CI_CORE_PORT}:8080"
            ecom.users.api:
              build:
                context: .
                dockerfile: Ecom.Users/src/Ecom.Users.API/Dockerfile
                args:
                  BUILDKIT_INLINE_CACHE: 1
              ports:
                - "${CI_USERS_PORT}:8080"
            prometheus:
              image: prom/prometheus
              volumes:
                - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
              ports:
                - "${CI_PROM_PORT}:9090"
            grafana:
              image: grafana/grafana
              environment:
                - GF_SECURITY_ADMIN_PASSWORD=admin123
                - GF_USERS_ALLOW_SIGN_UP=false
              ports:
                - "${CI_GF_PORT}:3000"
          EOF
          MAX_RETRIES=3; COUNT=0; SUCCESS=false
          until [ "$SUCCESS" = "true" ] || [ $COUNT -ge $MAX_RETRIES ]; do
            COUNT=$((COUNT+1))
            echo "Attempt $COUNT of $MAX_RETRIES"
            docker system prune -f || true
            if docker compose -f docker-compose.yml -f docker-compose.ci.yml build --no-cache; then
              SUCCESS=true
            elif [ $COUNT -eq 2 ]; then
              export DOCKER_BUILDKIT=0
            fi
            sleep 5
          done
          if [ "$SUCCESS" != "true" ]; then
            echo "Build failed after retries; running manual dotnet restore"
            dotnet restore Ecom.Core/src/Ecom.Core.API/Ecom.Core.API.csproj --verbosity detailed || true
            dotnet restore Ecom.Users/src/Ecom.Users.API/Ecom.Users.API.csproj --verbosity detailed || true
            docker compose -f docker-compose.yml -f docker-compose.ci.yml build --no-cache || true
          fi
          echo "âœ… Build done; spinning up"
          docker compose -f docker-compose.yml -f docker-compose.ci.yml up -d
          sleep 20
          curl -f http://localhost:$CI_CORE_PORT/health || true
          curl -f http://localhost:$CI_USERS_PORT/health || true
          curl -f http://localhost:$CI_PROM_PORT || true
          docker compose -f docker-compose.yml -f docker-compose.ci.yml down

      # 9) Build individual images for Kubernetes
      - name: Build individual images for Kubernetes
        run: |
          echo "ðŸ³ Building core API imageâ€¦"
          build_with_retry() {
            df=$1; tag=$2
            for i in 1 2 3; do
              echo "Try $i for $tag"
              if [ $i -eq 2 ]; then export DOCKER_BUILDKIT=0; fi
              if docker buildx build --file "$df" --tag "$tag" --load --progress=plain .; then
                return 0
              fi
              sleep 5
            done
            echo "Failed $tag"
          }
          build_with_retry "Ecom.Core/src/Ecom.Core.API/Dockerfile" "moclaw/ecom-core-api:latest"
          build_with_retry "Ecom.Users/src/Ecom.Users.API/Dockerfile" "moclaw/ecom-users-api:latest"
          docker images | grep moclaw || echo "âš ï¸ No moclaw images"

      # 10) Setup Minikube (disable storage addons)
      - name: Set up Minikube
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          container-runtime: docker
          kubernetes-version: 'v1.25.13'
          memory: '4096'
          cpus: '2'
          addons: dashboard

      # 11) Start Minikube explicitly
      - name: Start Minikube
        run: |
          echo "ðŸš€ Starting Minikube without storage addonsâ€¦"
          minikube start \
            --driver=docker \
            --kubernetes-version=v1.25.13 \
            --memory=4096 \
            --cpus=2 \
            --addons=dashboard \
            --disable-addons=storage-provisioner,default-storageclass \
            --embed-certs

      # 12) Verify Minikube status
      - name: Verify Minikube status
        run: |
          echo "ðŸ” Checking Minikube statusâ€¦"
          minikube status
          kubectl get nodes
          kubectl get pods -A

      # 13) Load images into Minikube
      - name: Load images to Minikube
        run: |
          echo "ðŸ”„ Loading imagesâ€¦"
          minikube image load moclaw/ecom-core-api:latest
          minikube image load moclaw/ecom-users-api:latest
          minikube image ls | grep moclaw

      # 14) Deploy manifests to Minikube
      - name: Deploy to Minikube
        run: |
          echo "ðŸš€ Applying k8s manifestsâ€¦"
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/configmap.yaml
          kubectl apply -f k8s/core-deployment.yaml
          kubectl apply -f k8s/users-deployment.yaml
          kubectl apply -f k8s/monitoring/prometheus-config.yaml
          kubectl rollout status deployment/ecom-core-api -n ecommerce --timeout=120s
          kubectl rollout status deployment/ecom-users-api -n ecommerce --timeout=120s

      # 15) Force deployment recovery if needed
      - name: Force deployment recovery if needed
        run: |
          NEED_RECOVERY=$(kubectl get deploy -n ecommerce \
            -o jsonpath='{.items[?(@.status.readyReplicas!=1)].metadata.name}')
          if [ -n "$NEED_RECOVERY" ]; then
            for d in $NEED_RECOVERY; do
              echo "Recovering $d"
              kubectl scale deployment "$d" --replicas=0 -n ecommerce
              sleep 5
              kubectl scale deployment "$d" --replicas=1 -n ecommerce
              sleep 10
            done
          fi

      # 16) Conditional production deployment
      - name: Conditional production deployment
        run: |
          PORTS_OK=true
          for p in 5301 5302 9090 3000; do
            sudo lsof -ti:"$p" && PORTS_OK=false
          done
          if [ "$PORTS_OK" = true ]; then
            echo "ðŸ“¦ Deploying prod composeâ€¦"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
            sleep 20
            curl -f http://localhost:5301/health || true
            curl -f http://localhost:5302/health || true
            curl -f http://localhost:9090 || true
            curl -f http://localhost:3000 || true
          else
            echo "âš ï¸ Ports busy; skipping prod compose"
          fi

      # 17) Display deployment summary
      - name: Display deployment summary
        run: |
          echo "=== DEPLOYMENT SUMMARY ==="
          if docker compose ps | grep -q Up; then
            echo "Compose services running on ports 5301,5302,9090,3000"
          else
            echo "Compose not running"
          fi
          IP=$(minikube ip)
          echo "Minikube services:"
          kubectl get svc -n ecommerce -o wide
          echo "Current Docker containers:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
