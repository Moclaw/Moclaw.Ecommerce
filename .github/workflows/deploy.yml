name: Ecommerce CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  DOCKER_REGISTRY: localhost:5000
  KUBECTL_VERSION: v1.28.0

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Cache .NET dependencies
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Start Minikube
      uses: medyagh/setup-minikube@master
      with:
        minikube-version: 1.32.0
        kubernetes-version: v1.28.0
        driver: docker
        addons: |
          registry
          ingress

    - name: Add Worker Node
      run: |
        minikube node add

    - name: Label Minikube Nodes
      run: |
        # Wait for nodes to be ready
        kubectl wait --for=condition=Ready nodes --all --timeout=300s
        
        # Get node names
        NODES=($(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'))
        
        # Label first node for core service
        kubectl label nodes ${NODES[0]} service=core --overwrite
        echo "Labeled ${NODES[0]} for core service"
        
        # Label second node for users service (if exists, otherwise use same node)
        if [ ${#NODES[@]} -gt 1 ]; then
          kubectl label nodes ${NODES[1]} service=users --overwrite
          echo "Labeled ${NODES[1]} for users service"
        else
          kubectl label nodes ${NODES[0]} service=users --overwrite
          echo "Labeled ${NODES[0]} for users service (single node setup)"
        fi
        
        # Display node labels
        kubectl get nodes --show-labels

    - name: Run Tests
      run: |
        # Test Core service
        dotnet test Ecom.Core/test/EcomCore.Application.UnitTests/EcomCore.Application.UnitTests.csproj --configuration Release --logger trx --collect:"XPlat Code Coverage"
        dotnet test Ecom.Core/test/EcomCore.Domain.UnitTests/EcomCore.Domain.UnitTests.csproj --configuration Release --logger trx --collect:"XPlat Code Coverage"
        dotnet test Ecom.Core/test/EcomCore.Infrastructure.UnitTests/EcomCore.Infrastructure.UnitTests.csproj --configuration Release --logger trx --collect:"XPlat Code Coverage"
        
        # Test Users service
        dotnet test Ecom.Users/test/Ecom.Users.Application.UnitTests/Ecom.Users.Application.UnitTests.csproj --configuration Release --logger trx --collect:"XPlat Code Coverage"
        dotnet test Ecom.Users/test/Ecom.Users.Domain.UnitTests/Ecom.Users.Domain.UnitTests.csproj --configuration Release --logger trx --collect:"XPlat Code Coverage"
        dotnet test Ecom.Users/test/Ecom.Users.Infrastructure.UnitTests/Ecom.Users.Infrastructure.UnitTests.csproj --configuration Release --logger trx --collect:"XPlat Code Coverage"

    - name: Build Docker Images
      run: |
        # Wait for registry to be ready
        echo "Waiting for registry to be available..."
        kubectl wait --for=condition=ready pod -l kubernetes.io/minikube-addons=registry -n kube-system --timeout=300s
        
        # Get registry service details
        REGISTRY_SERVICE=$(kubectl get svc -n kube-system -l kubernetes.io/minikube-addons=registry -o jsonpath='{.items[0].metadata.name}')
        echo "Registry service: $REGISTRY_SERVICE"
        
        # Set up registry port-forward with proper cleanup
        kubectl port-forward -n kube-system svc/$REGISTRY_SERVICE 5000:80 &
        REGISTRY_PF_PID=$!
        echo "Registry port-forward PID: $REGISTRY_PF_PID"
        
        # Wait for port-forward to be ready
        sleep 15
        
        # Test registry connectivity
        curl -f http://localhost:5000/v2/ || echo "Registry not ready yet, waiting more..."
        sleep 10
        
        # Configure Docker for insecure registry
        sudo mkdir -p /etc/docker
        echo '{"insecure-registries":["localhost:5000"]}' | sudo tee /etc/docker/daemon.json
        sudo systemctl restart docker
        
        # Wait for Docker to restart
        sleep 10
        
        # Build and tag images
        echo "Building Core API image..."
        docker build -t ecom-core-api:latest -f Ecom.Core/src/Ecom.Core.API/Dockerfile .
        docker tag ecom-core-api:latest localhost:5000/ecom-core-api:latest
        
        echo "Building Users API image..."
        docker build -t ecom-users-api:latest -f Ecom.Users/src/Ecom.Users.API/Dockerfile .
        docker tag ecom-users-api:latest localhost:5000/ecom-users-api:latest
        
        # Push images to registry with retry
        echo "Pushing Core API image..."
        for i in {1..3}; do
          if docker push localhost:5000/ecom-core-api:latest; then
            echo "Core API image pushed successfully"
            break
          else
            echo "Push attempt $i failed, retrying..."
            sleep 5
          fi
        done
        
        echo "Pushing Users API image..."
        for i in {1..3}; do
          if docker push localhost:5000/ecom-users-api:latest; then
            echo "Users API image pushed successfully"
            break
          else
            echo "Push attempt $i failed, retrying..."
            sleep 5
          fi
        done
        
        # Verify images in registry
        echo "Verifying images in registry:"
        curl -s http://localhost:5000/v2/_catalog | jq .
        
        # Store PID for cleanup
        echo "REGISTRY_PF_PID=$REGISTRY_PF_PID" >> $GITHUB_ENV

    - name: Create Kubernetes Namespace
      run: |
        kubectl apply -f k8s/namespace.yml
        
        # Create secrets if the file exists
        if [ -f "k8s/storage-secrets.yml" ]; then
          kubectl apply -f k8s/storage-secrets.yml
        fi
        
        # Clean up registry port-forward
        if [ ! -z "$REGISTRY_PF_PID" ]; then
          kill $REGISTRY_PF_PID || true
        fi

    - name: Deploy Core Service
      run: |
        kubectl apply -f k8s/core-service/
        
        # Wait for Core deployment to be ready
        kubectl wait --for=condition=available --timeout=300s deployment/ecom-core-api -n ecommerce

    - name: Deploy Users Service
      run: |
        kubectl apply -f k8s/users-service/
        
        # Wait for Users deployment to be ready
        kubectl wait --for=condition=available --timeout=300s deployment/ecom-users-api -n ecommerce

    - name: Verify Deployments
      run: |
        echo "=== Checking deployments ==="
        kubectl get deployments -n ecommerce
        
        echo "=== Checking pods ==="
        kubectl get pods -n ecommerce -o wide
        
        echo "=== Checking services ==="
        kubectl get services -n ecommerce
        
        echo "=== Checking ingress ==="
        kubectl get ingress -n ecommerce
        
        echo "=== Node assignments ==="
        kubectl get pods -n ecommerce -o wide --show-labels

    - name: Health Check
      run: |
        # Wait for pods to be ready
        kubectl wait --for=condition=ready pod -l app=ecom-core-api -n ecommerce --timeout=300s
        kubectl wait --for=condition=ready pod -l app=ecom-users-api -n ecommerce --timeout=300s
        
        # Get Minikube IP for testing
        MINIKUBE_IP=$(minikube ip)
        echo "Minikube IP: $MINIKUBE_IP"
        
        # Test Core service
        echo "Testing Core service..."
        kubectl port-forward -n ecommerce service/ecom-core-service 8080:80 &
        CORE_PF_PID=$!
        sleep 10
        
        # Simple health check for Core
        curl -f http://localhost:8080/health || echo "Core service health check failed"
        kill $CORE_PF_PID
        
        # Test Users service
        echo "Testing Users service..."
        kubectl port-forward -n ecommerce service/ecom-users-service 8081:80 &
        USERS_PF_PID=$!
        sleep 10
        
        # Simple health check for Users
        curl -f http://localhost:8081/health || echo "Users service health check failed"
        kill $USERS_PF_PID

    - name: Generate Deployment Summary
      if: always()
      run: |
        echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "### Services Deployed:" >> $GITHUB_STEP_SUMMARY
        echo "- Core Service: ecom-core-api" >> $GITHUB_STEP_SUMMARY
        echo "- Users Service: ecom-users-api" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Node Distribution:" >> $GITHUB_STEP_SUMMARY
        kubectl get pods -n ecommerce -o wide --no-headers | awk '{print "- " $1 " -> " $7}' >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Access URLs:" >> $GITHUB_STEP_SUMMARY
        echo "- Core API: http://core.ecommerce.local" >> $GITHUB_STEP_SUMMARY
        echo "- Users API: http://users.ecommerce.local" >> $GITHUB_STEP_SUMMARY

  cleanup:
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: always()
    
    steps:
    - name: Cleanup Minikube
      if: github.event_name == 'pull_request'
      run: |
        minikube delete || true
