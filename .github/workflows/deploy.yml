name: CI/CD for Docker Compose and Minikube

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: self-hosted

    steps:
      - name: Pre-clean workspace
        run: |
          echo "üßπ Cleaning workspace..."
          docker stop $(docker ps -aq) 2>/dev/null || true
          docker rm $(docker ps -aq) 2>/dev/null || true
          docker system prune -f || true
          sudo rm -rf ./monitoring 2>/dev/null || true
          for port in 5301 5302 9090 3000; do
            sudo lsof -ti:$port | xargs -r sudo kill -9 || true
          done

      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup .NET
        run: |
          if ! command -v dotnet &> /dev/null; then
            echo "Installing .NET..."
            mkdir -p "$HOME/.dotnet"
            export DOTNET_ROOT="$HOME/.dotnet"
            export PATH="$DOTNET_ROOT:$PATH"
            curl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --channel 9.0 --install-dir "$HOME/.dotnet"
            echo "DOTNET_ROOT=$HOME/.dotnet" >> "$GITHUB_ENV"
            echo "$HOME/.dotnet" >> "$GITHUB_PATH"
            # Verify installation with full path
            "$HOME/.dotnet/dotnet" --version
          else
            echo ".NET already available"
            dotnet --version
          fi

      - name: Create monitoring configuration
        run: |
          echo "‚öôÔ∏è Creating monitoring config..."
          mkdir -p monitoring/dashboards
          
          cat > monitoring/prometheus.yml << 'EOF'
          global:
            scrape_interval: 15s
          scrape_configs:
            - job_name: 'ecom-core-api'
              static_configs:
                - targets: ['ecom.core.api:8080']
              metrics_path: '/metrics'
            - job_name: 'ecom-users-api'
              static_configs:
                - targets: ['ecom.users.api:8080']
              metrics_path: '/metrics'
          EOF
          
          cat > monitoring/dashboards/ecommerce-api.json << 'EOF'
          {
            "dashboard": {
              "title": "Ecommerce API Metrics",
              "panels": [
                {
                  "title": "HTTP Requests Rate",
                  "type": "graph",
                  "targets": [{"expr": "rate(http_requests_total[5m])"}],
                  "gridPos": {"h": 8, "w": 12, "x": 0, "y": 0}
                }
              ],
              "time": {"from": "now-1h", "to": "now"}
            }
          }
          EOF

      - name: Build Docker images
        run: |
          echo "üê≥ Building images..."
          
          # Function to build with retries
          build_image() {
            local dockerfile=$1
            local tag=$2
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts for $tag"
              
              # Clean up any partial builds
              docker system prune -f || true
              
              # Try building with different strategies
              if [ $attempt -eq 1 ]; then
                # First attempt with BuildKit
                DOCKER_BUILDKIT=1 docker build -f "$dockerfile" -t "$tag" . && return 0
              elif [ $attempt -eq 2 ]; then
                # Second attempt without BuildKit
                DOCKER_BUILDKIT=0 docker build -f "$dockerfile" -t "$tag" . && return 0
              else
                # Third attempt with no cache
                DOCKER_BUILDKIT=0 docker build --no-cache -f "$dockerfile" -t "$tag" . && return 0
              fi
              
              echo "Build attempt $attempt failed, cleaning up..."
              docker system prune -f || true
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå Failed to build $tag after $max_attempts attempts"
            return 1
          }
          
          # Build Core API
          if ! build_image "Ecom.Core/src/Ecom.Core.API/Dockerfile" "moclaw/ecom-core-api:latest"; then
            echo "‚ùå Core API build failed"
            exit 1
          fi
          
          # Build Users API  
          if ! build_image "Ecom.Users/src/Ecom.Users.API/Dockerfile" "moclaw/ecom-users-api:latest"; then
            echo "‚ùå Users API build failed"
            exit 1
          fi
          
          echo "‚úÖ All images built successfully"
          docker images | grep moclaw

      - name: Setup Minikube
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          kubernetes-version: 'v1.33.1'
          memory: '4096'
          cpus: '2'
          start: false

      - name: Start Minikube
        run: |
          echo "üöÄ Starting Minikube..."
          # Delete existing cluster if it exists to avoid version conflicts
          minikube delete || true
          
          # Start with basic configuration
          minikube start \
            --driver=docker \
            --kubernetes-version=v1.33.1 \
            --memory=4096 \
            --cpus=2 \
            --wait=all
          
          # Disable problematic addons after start
          minikube addons disable storage-provisioner || true
          minikube addons disable default-storageclass || true
          
          # Wait for cluster to be fully ready
          echo "‚è≥ Waiting for cluster to be ready..."
          kubectl wait --for=condition=Ready nodes --all --timeout=300s
          
          # Verify cluster status
          kubectl get nodes
          kubectl cluster-info

      - name: Load images to Minikube
        run: |
          echo "üîÑ Loading images..."
          minikube image load moclaw/ecom-core-api:latest
          minikube image load moclaw/ecom-users-api:latest

      - name: Deploy to Minikube
        run: |
          echo "üöÄ Deploying to Kubernetes..."
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/configmap.yaml
          kubectl apply -f k8s/core-deployment.yaml
          kubectl apply -f k8s/users-deployment.yaml
          
          # Create monitoring namespace
          kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
          
          # Deploy Prometheus
          kubectl apply -f - << 'EOF'
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: prometheus
            namespace: monitoring
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: prometheus
            template:
              metadata:
                labels:
                  app: prometheus
              spec:
                containers:
                - name: prometheus
                  image: prom/prometheus:latest
                  ports:
                  - containerPort: 9090
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: prometheus
            namespace: monitoring
          spec:
            type: NodePort
            ports:
            - port: 9090
              nodePort: 30090
            selector:
              app: prometheus
          EOF
          
          # Deploy Grafana
          kubectl apply -f - << 'EOF'
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: grafana
            namespace: monitoring
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: grafana
            template:
              metadata:
                labels:
                  app: grafana
              spec:
                containers:
                - name: grafana
                  image: grafana/grafana:latest
                  ports:
                  - containerPort: 3000
                  env:
                  - name: GF_SECURITY_ADMIN_PASSWORD
                    value: "admin123"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: grafana
            namespace: monitoring
          spec:
            type: NodePort
            ports:
            - port: 3000
              nodePort: 30030
            selector:
              app: grafana
          EOF
          
          echo "üìä Checking deployment status..."
          
          # Function to check deployment with debugging
          check_deployment() {
            local deployment=$1
            local namespace=$2
            local timeout=${3:-60}
            
            echo "Checking deployment $deployment in namespace $namespace..."
            
            # Check if deployment exists
            if ! kubectl get deployment $deployment -n $namespace &>/dev/null; then
              echo "‚ùå Deployment $deployment not found in namespace $namespace"
              return 1
            fi
            
            # Wait with shorter timeout and better error handling
            if ! kubectl rollout status deployment/$deployment -n $namespace --timeout=${timeout}s; then
              echo "‚ö†Ô∏è Deployment $deployment timed out, checking status..."
              
              # Debug information
              echo "Pod status:"
              kubectl get pods -n $namespace -l app=$deployment
              echo "Pod describe:"
              kubectl describe pods -n $namespace -l app=$deployment
              echo "Deployment describe:"
              kubectl describe deployment $deployment -n $namespace
              
              # Try to restart deployment
              echo "üîÑ Restarting deployment $deployment..."
              kubectl rollout restart deployment/$deployment -n $namespace
              sleep 30
              
              # Check again with shorter timeout
              if ! kubectl rollout status deployment/$deployment -n $namespace --timeout=60s; then
                echo "‚ùå Deployment $deployment failed after restart"
                return 1
              fi
            fi
            
            echo "‚úÖ Deployment $deployment is ready"
            return 0
          }
          
          # Check deployments one by one with better error handling
          check_deployment "ecom-core-api" "ecommerce" 90 || echo "‚ö†Ô∏è Core API deployment issues"
          check_deployment "ecom-users-api" "ecommerce" 90 || echo "‚ö†Ô∏è Users API deployment issues"
          check_deployment "prometheus" "monitoring" 60 || echo "‚ö†Ô∏è Prometheus deployment issues"
          check_deployment "grafana" "monitoring" 60 || echo "‚ö†Ô∏è Grafana deployment issues"
          
          echo "üìã Final deployment status:"
          kubectl get deployments -n ecommerce
          kubectl get deployments -n monitoring
          kubectl get pods -n ecommerce
          kubectl get pods -n monitoring

      - name: Deploy production services
        run: |
          echo "üì¶ Deploying production services..."
          docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
          sleep 20
          
          # Health checks
          curl -f http://localhost:5301/health || echo "Core API not ready"
          curl -f http://localhost:5302/health || echo "Users API not ready"
          curl -f http://localhost:9090 || echo "Prometheus not ready"
          curl -f http://localhost:3000 || echo "Grafana not ready"

      - name: Display deployment summary
        run: |
          echo "=== DEPLOYMENT SUMMARY ==="
          IP=$(minikube ip)
          echo "üåê Services:"
          echo "  - Core API: http://localhost:5301"
          echo "  - Users API: http://localhost:5302"
          echo "  - Prometheus: http://localhost:9090 | http://$IP:30090"
          echo "  - Grafana: http://localhost:3000 | http://$IP:30030 (admin/admin123)"
          
          echo ""
          echo "üìä Kubernetes Status:"
          kubectl get svc -n ecommerce
          kubectl get svc -n monitoring
